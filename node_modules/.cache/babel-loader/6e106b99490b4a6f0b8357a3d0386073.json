{"ast":null,"code":"// From https://github.com/pathable/truncate/\n(function ($) {\n  // Matches trailing non-space characters.\n  var chop = /(\\s*\\S+|\\s)$/; // Matches the first word in the string.\n\n  var start = /^(\\S*)/; // Return a truncated html string.  Delegates to $.fn.truncate.\n\n  $.truncate = function (html, options) {\n    return $('<div></div>').append(html).truncate(options).html();\n  }; // Truncate the contents of an element in place.\n\n\n  $.fn.truncate = function (options) {\n    if ($.isNumeric(options)) options = {\n      length: options\n    };\n    var o = $.extend({}, $.truncate.defaults, options);\n    return this.each(function () {\n      var self = $(this);\n      if (o.noBreaks) self.find('br').replaceWith(' ');\n      var text = self.text();\n      var excess = text.length - o.length;\n      if (o.stripTags) self.text(text); // Chop off any partial words if appropriate.\n\n      if (o.words && excess > 0) {\n        var truncated = text.slice(0, o.length).replace(chop, '').length;\n\n        if (o.keepFirstWord && truncated === 0) {\n          excess = text.length - start.exec(text)[0].length - 1;\n        } else {\n          excess = text.length - truncated - 1;\n        }\n      }\n\n      if (excess < 0 || !excess && !o.truncated) return; // Iterate over each child node in reverse, removing excess text.\n\n      $.each(self.contents().get().reverse(), function (i, el) {\n        var $el = $(el);\n        var text = $el.text();\n        var length = text.length; // If the text is longer than the excess, remove the node and continue.\n\n        if (length <= excess) {\n          o.truncated = true;\n          excess -= length;\n          $el.remove();\n          return;\n        } // Remove the excess text and append the ellipsis.\n\n\n        if (el.nodeType === 3) {\n          // should we finish the block anyway?\n          if (o.finishBlock) {\n            $(el.splitText(length)).replaceWith(o.ellipsis);\n          } else {\n            $(el.splitText(length - excess - 1)).replaceWith(o.ellipsis);\n          }\n\n          return false;\n        } // Recursively truncate child nodes.\n\n\n        $el.truncate($.extend(o, {\n          length: length - excess\n        }));\n        return false;\n      });\n    });\n  };\n\n  $.truncate.defaults = {\n    // Strip all html elements, leaving only plain text.\n    stripTags: false,\n    // Only truncate at word boundaries.\n    words: false,\n    // When 'words' is active, keeps the first word in the string\n    // even if it's longer than a target length.\n    keepFirstWord: false,\n    // Replace instances of <br> with a single space.\n    noBreaks: false,\n    // if true always truncate the content at the end of the block.\n    finishBlock: false,\n    // The maximum length of the truncated html.\n    length: Infinity,\n    // The character to use as the ellipsis.  The word joiner (U+2060) can be\n    // used to prevent a hanging ellipsis, but displays incorrectly in Chrome\n    // on Windows 7.\n    // http://code.google.com/p/chromium/issues/detail?id=68323\n    ellipsis: \"\\u2026\" // '\\u2060\\u2026'\n\n  };\n})(jQuery);","map":{"version":3,"mappings":"AAAA;AAEA,CAAC,UAASA,CAAT,EAAY;EAEX;EACA,IAAIC,IAAI,GAAG,cAAX,CAHW,CAKX;;EACA,IAAIC,KAAK,GAAG,QAAZ,CANW,CAQX;;EACAF,CAAC,CAACG,QAAFH,GAAa,UAASI,IAAT,EAAeC,OAAf,EAAwB;IACnC,OAAOL,CAAC,CAAC,aAAD,CAADA,CAAiBM,MAAjBN,CAAwBI,IAAxBJ,EAA8BG,QAA9BH,CAAuCK,OAAvCL,EAAgDI,IAAhDJ,EAAP;EADF,EATW,CAaX;;;EACAA,CAAC,CAACO,EAAFP,CAAKG,QAALH,GAAgB,UAASK,OAAT,EAAkB;IAChC,IAAIL,CAAC,CAACQ,SAAFR,CAAYK,OAAZL,CAAJ,EAA0BK,OAAO,GAAG;MAAEI,MAAM,EAAEJ;IAAV,CAAVA;IAC1B,IAAIK,CAAC,GAAGV,CAAC,CAACW,MAAFX,CAAS,EAATA,EAAaA,CAAC,CAACG,QAAFH,CAAWY,QAAxBZ,EAAkCK,OAAlCL,CAAR;IAEA,OAAO,KAAKa,IAAL,CAAU,YAAW;MAC1B,IAAIC,IAAI,GAAGd,CAAC,CAAC,IAAD,CAAZ;MAEA,IAAIU,CAAC,CAACK,QAAN,EAAgBD,IAAI,CAACE,IAALF,CAAU,IAAVA,EAAgBG,WAAhBH,CAA4B,GAA5BA;MAEhB,IAAII,IAAI,GAAGJ,IAAI,CAACI,IAALJ,EAAX;MACA,IAAIK,MAAM,GAAGD,IAAI,CAACT,MAALS,GAAcR,CAAC,CAACD,MAA7B;MAEA,IAAIC,CAAC,CAACU,SAAN,EAAiBN,IAAI,CAACI,IAALJ,CAAUI,IAAVJ,EARS,CAU1B;;MACA,IAAIJ,CAAC,CAACW,KAAFX,IAAWS,MAAM,GAAG,CAAxB,EAA2B;QACzB,IAAIG,SAAS,GAAGJ,IAAI,CAACK,KAALL,CAAW,CAAXA,EAAcR,CAAC,CAACD,MAAhBS,EAAwBM,OAAxBN,CAAgCjB,IAAhCiB,EAAsC,EAAtCA,EAA0CT,MAA1D;;QAEA,IAAIC,CAAC,CAACe,aAAFf,IAAmBY,SAAS,KAAK,CAArC,EAAwC;UACtCH,MAAM,GAAGD,IAAI,CAACT,MAALS,GAAchB,KAAK,CAACwB,IAANxB,CAAWgB,IAAXhB,EAAiB,CAAjBA,EAAoBO,MAAlCS,GAA2C,CAApDC;QADF,OAEO;UACLA,MAAM,GAAGD,IAAI,CAACT,MAALS,GAAcI,SAAdJ,GAA0B,CAAnCC;QACD;MACF;;MAED,IAAIA,MAAM,GAAG,CAATA,IAAc,CAACA,MAAD,IAAW,CAACT,CAAC,CAACY,SAAhC,EAA2C,OArBjB,CAuB1B;;MACAtB,CAAC,CAACa,IAAFb,CAAOc,IAAI,CAACa,QAALb,GAAgBc,GAAhBd,GAAsBe,OAAtBf,EAAPd,EAAwC,UAAS8B,CAAT,EAAYC,EAAZ,EAAgB;QACtD,IAAIC,GAAG,GAAGhC,CAAC,CAAC+B,EAAD,CAAX;QACA,IAAIb,IAAI,GAAGc,GAAG,CAACd,IAAJc,EAAX;QACA,IAAIvB,MAAM,GAAGS,IAAI,CAACT,MAAlB,CAHsD,CAKtD;;QACA,IAAIA,MAAM,IAAIU,MAAd,EAAsB;UACpBT,CAAC,CAACY,SAAFZ,GAAc,IAAdA;UACAS,MAAM,IAAIV,MAAVU;UACAa,GAAG,CAACC,MAAJD;UACA;QAVoD,EAatD;;;QACA,IAAID,EAAE,CAACG,QAAHH,KAAgB,CAApB,EAAuB;UACrB;UACA,IAAIrB,CAAC,CAACyB,WAAN,EAAmB;YACjBnC,CAAC,CAAC+B,EAAE,CAACK,SAAHL,CAAatB,MAAbsB,CAAD,CAAD/B,CAAwBiB,WAAxBjB,CAAoCU,CAAC,CAAC2B,QAAtCrC;UADF,OAEO;YACLA,CAAC,CAAC+B,EAAE,CAACK,SAAHL,CAAatB,MAAM,GAAGU,MAATV,GAAkB,CAA/BsB,CAAD,CAAD/B,CAAqCiB,WAArCjB,CAAiDU,CAAC,CAAC2B,QAAnDrC;UACD;;UACD,OAAO,KAAP;QArBoD,EAwBtD;;;QACAgC,GAAG,CAAC7B,QAAJ6B,CAAahC,CAAC,CAACW,MAAFX,CAASU,CAATV,EAAY;UAAES,MAAM,EAAEA,MAAM,GAAGU;QAAnB,CAAZnB,CAAbgC;QACA,OAAO,KAAP;MA1BF;IAxBK,EAAP;EAJF;;EA2DAhC,CAAC,CAACG,QAAFH,CAAWY,QAAXZ,GAAsB;IAEpB;IACAoB,SAAS,EAAE,KAHS;IAKpB;IACAC,KAAK,EAAE,KANa;IAQpB;IACA;IACAI,aAAa,EAAE,KAVK;IAYpB;IACAV,QAAQ,EAAE,KAbU;IAepB;IACAoB,WAAW,EAAE,KAhBO;IAkBpB;IACA1B,MAAM,EAAE6B,QAnBY;IAqBpB;IACA;IACA;IACA;IACAD,QAAQ,EAAE,QAzBU,CAyBD;;EAzBC,CAAtBrC;AAzEF,GAsGGuC,MAtGH","names":["$","chop","start","truncate","html","options","append","fn","isNumeric","length","o","extend","defaults","each","self","noBreaks","find","replaceWith","text","excess","stripTags","words","truncated","slice","replace","keepFirstWord","exec","contents","get","reverse","i","el","$el","remove","nodeType","finishBlock","splitText","ellipsis","Infinity","jQuery"],"sources":["/home/injam/.rbenv/versions/2.7.5/lib/ruby/gems/2.7.0/gems/decidim-decidim_awesome-0.8.3/app/packs/src/vendor/jquery.truncate.js"],"sourcesContent":["// From https://github.com/pathable/truncate/\n\n(function($) {\n\n  // Matches trailing non-space characters.\n  var chop = /(\\s*\\S+|\\s)$/;\n\n  // Matches the first word in the string.\n  var start = /^(\\S*)/;\n\n  // Return a truncated html string.  Delegates to $.fn.truncate.\n  $.truncate = function(html, options) {\n    return $('<div></div>').append(html).truncate(options).html();\n  };\n\n  // Truncate the contents of an element in place.\n  $.fn.truncate = function(options) {\n    if ($.isNumeric(options)) options = { length: options };\n    var o = $.extend({}, $.truncate.defaults, options);\n\n    return this.each(function() {\n      var self = $(this);\n\n      if (o.noBreaks) self.find('br').replaceWith(' ');\n\n      var text = self.text();\n      var excess = text.length - o.length;\n\n      if (o.stripTags) self.text(text);\n\n      // Chop off any partial words if appropriate.\n      if (o.words && excess > 0) {\n        var truncated = text.slice(0, o.length).replace(chop, '').length;\n\n        if (o.keepFirstWord && truncated === 0) {\n          excess = text.length - start.exec(text)[0].length - 1;\n        } else {\n          excess = text.length - truncated - 1;\n        }\n      }\n\n      if (excess < 0 || !excess && !o.truncated) return;\n\n      // Iterate over each child node in reverse, removing excess text.\n      $.each(self.contents().get().reverse(), function(i, el) {\n        var $el = $(el);\n        var text = $el.text();\n        var length = text.length;\n\n        // If the text is longer than the excess, remove the node and continue.\n        if (length <= excess) {\n          o.truncated = true;\n          excess -= length;\n          $el.remove();\n          return;\n        }\n\n        // Remove the excess text and append the ellipsis.\n        if (el.nodeType === 3) {\n          // should we finish the block anyway?\n          if (o.finishBlock) {\n            $(el.splitText(length)).replaceWith(o.ellipsis);\n          } else {\n            $(el.splitText(length - excess - 1)).replaceWith(o.ellipsis);\n          }\n          return false;\n        }\n\n        // Recursively truncate child nodes.\n        $el.truncate($.extend(o, { length: length - excess }));\n        return false;\n      });\n    });\n  };\n\n  $.truncate.defaults = {\n\n    // Strip all html elements, leaving only plain text.\n    stripTags: false,\n\n    // Only truncate at word boundaries.\n    words: false,\n\n    // When 'words' is active, keeps the first word in the string\n    // even if it's longer than a target length.\n    keepFirstWord: false,\n\n    // Replace instances of <br> with a single space.\n    noBreaks: false,\n\n    // if true always truncate the content at the end of the block.\n    finishBlock: false,\n\n    // The maximum length of the truncated html.\n    length: Infinity,\n\n    // The character to use as the ellipsis.  The word joiner (U+2060) can be\n    // used to prevent a hanging ellipsis, but displays incorrectly in Chrome\n    // on Windows 7.\n    // http://code.google.com/p/chromium/issues/detail?id=68323\n    ellipsis: '\\u2026' // '\\u2060\\u2026'\n\n  };\n\n})(jQuery);\n"]},"metadata":{},"sourceType":"module"}