{"ast":null,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\n\nvar COUNT_KEY = \"%count%\";\nvar DEFAULT_MESSAGES = {\n  charactersAtLeast: {\n    one: \"at least \".concat(COUNT_KEY, \" character\"),\n    other: \"at least \".concat(COUNT_KEY, \" characters\")\n  },\n  charactersLeft: {\n    one: \"\".concat(COUNT_KEY, \" character left\"),\n    other: \"\".concat(COUNT_KEY, \" characters left\")\n  }\n};\nvar MESSAGES = DEFAULT_MESSAGES;\n\nvar InputCharacterCounter = /*#__PURE__*/function () {\n  function InputCharacterCounter(input) {\n    _classCallCheck(this, InputCharacterCounter);\n\n    this.$input = input;\n    this.$target = $(this.$input.data(\"remaining-characters\"));\n    this.minCharacters = parseInt(this.$input.attr(\"minlength\"), 10);\n    this.maxCharacters = parseInt(this.$input.attr(\"maxlength\"), 10);\n\n    if (this.$target.length < 1) {\n      var targetId = null;\n\n      if (this.$input.attr(\"id\") && this.$input.attr(\"id\").length > 0) {\n        targetId = \"\".concat(this.$input.attr(\"id\"), \"_characters\");\n      } else {\n        targetId = \"characters_\".concat(Math.random().toString(36).substr(2, 9));\n      }\n\n      this.$target = $(\"<span id=\\\"\".concat(targetId, \"\\\" class=\\\"form-input-extra-before\\\" />\")); // If input is a hidden for WYSIWYG editor add it at the end\n\n      if (this.$input.parent().is(\".editor\")) {\n        this.$input.parent().after(this.$target);\n      } // Prefix and suffix columns are wrapped in columns, so put the\n      // character counter before that.\n      else if (this.$input.parent().is(\".columns\") && this.$input.parent().parent().is(\".row\")) {\n        this.$input.parent().parent().after(this.$target);\n      } else {\n        this.$input.after(this.$target);\n      }\n    }\n\n    if (this.$target.length > 0 && (this.maxCharacters > 0 || this.minCharacters > 0)) {\n      this.bindEvents();\n    }\n  }\n\n  _createClass(InputCharacterCounter, [{\n    key: \"bindEvents\",\n    value: function bindEvents() {\n      var _this = this; // In WYSIWYG editors (Quill) we need to find the active editor from the\n      // DOM node. Quill has the experimental \"find\" method that should work\n      // fine in this case\n\n\n      if (Quill && this.$input.parent().is(\".editor\")) {\n        // Wait until the next javascript loop so Quill editors are created\n        setTimeout(function () {\n          var editor = Quill.find(_this.$input.siblings(\".editor-container\")[0]);\n          editor.on(\"text-change\", function () {\n            _this.updateStatus();\n          });\n        });\n      }\n\n      this.$input.on(\"keyup\", function () {\n        _this.updateStatus();\n      });\n\n      if (this.$input.get(0) !== null) {\n        this.$input.get(0).addEventListener(\"emoji.added\", function () {\n          _this.updateStatus();\n        });\n      }\n\n      this.updateStatus();\n    }\n  }, {\n    key: \"updateStatus\",\n    value: function updateStatus() {\n      var numCharacters = this.$input.val().length;\n      var showMessages = [];\n\n      if (this.minCharacters > 0) {\n        var message = MESSAGES.charactersAtLeast.other;\n\n        if (this.minCharacters === 1) {\n          message = MESSAGES.charactersAtLeast.one;\n        }\n\n        showMessages.push(message.replace(COUNT_KEY, this.minCharacters));\n      }\n\n      if (this.maxCharacters > 0) {\n        var remaining = this.maxCharacters - numCharacters;\n        var _message = MESSAGES.charactersLeft.other;\n\n        if (remaining === 1) {\n          _message = MESSAGES.charactersLeft.one;\n        }\n\n        this.$input[0].dispatchEvent(new CustomEvent(\"characterCounter\", {\n          detail: {\n            remaining: remaining\n          }\n        }));\n        showMessages.push(_message.replace(COUNT_KEY, remaining));\n      }\n\n      this.$target.text(showMessages.join(\", \"));\n    }\n  }], [{\n    key: \"configureMessages\",\n    value: function configureMessages(messages) {\n      MESSAGES = $.extend(DEFAULT_MESSAGES, messages);\n    }\n  }]);\n\n  return InputCharacterCounter;\n}();\n\nexport { InputCharacterCounter as default };\n\nvar createCharacterCounter = function createCharacterCounter($input) {\n  $input.data(\"remaining-characters-counter\", new InputCharacterCounter($input));\n};\n\n$(function () {\n  $(\"input[type='text'], textarea, .editor>input[type='hidden']\").each(function (_i, elem) {\n    var $input = $(elem);\n\n    if (!$input.is(\"[minlength]\") && !$input.is(\"[maxlength]\")) {\n      return;\n    }\n\n    createCharacterCounter($input);\n  });\n});\nexport { InputCharacterCounter, createCharacterCounter };","map":{"version":3,"mappings":"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","names":["COUNT_KEY","DEFAULT_MESSAGES","charactersAtLeast","one","other","charactersLeft","MESSAGES","InputCharacterCounter","input","_classCallCheck","$input","$target","$","data","minCharacters","parseInt","attr","maxCharacters","length","targetId","Math","random","toString","substr","parent","is","after","bindEvents","Quill","setTimeout","editor","find","_this","siblings","on","updateStatus","get","addEventListener","numCharacters","val","showMessages","message","push","replace","remaining","dispatchEvent","CustomEvent","detail","text","join","messages","extend","createCharacterCounter","each","_i","elem"],"sources":["/home/injam/.rbenv/versions/2.7.5/lib/ruby/gems/2.7.0/gems/decidim-core-0.26.2/app/packs/src/decidim/input_character_counter.js"],"sourcesContent":["const COUNT_KEY = \"%count%\";\nconst DEFAULT_MESSAGES = {\n  charactersAtLeast: {\n    one: `at least ${COUNT_KEY} character`,\n    other: `at least ${COUNT_KEY} characters`\n  },\n  charactersLeft: {\n    one: `${COUNT_KEY} character left`,\n    other: `${COUNT_KEY} characters left`\n  }\n};\nlet MESSAGES = DEFAULT_MESSAGES;\n\nexport default class InputCharacterCounter {\n  static configureMessages(messages) {\n    MESSAGES = $.extend(DEFAULT_MESSAGES, messages);\n  }\n\n  constructor(input) {\n    this.$input = input;\n    this.$target = $(this.$input.data(\"remaining-characters\"));\n    this.minCharacters = parseInt(this.$input.attr(\"minlength\"), 10);\n    this.maxCharacters = parseInt(this.$input.attr(\"maxlength\"), 10);\n\n    if (this.$target.length < 1) {\n      let targetId = null;\n      if (this.$input.attr(\"id\") && this.$input.attr(\"id\").length > 0) {\n        targetId = `${this.$input.attr(\"id\")}_characters`;\n      } else {\n        targetId = `characters_${Math.random().toString(36).substr(2, 9)}`;\n      }\n\n      this.$target = $(`<span id=\"${targetId}\" class=\"form-input-extra-before\" />`)\n\n      // If input is a hidden for WYSIWYG editor add it at the end\n      if (this.$input.parent().is(\".editor\")) {\n        this.$input.parent().after(this.$target);\n      }\n      // Prefix and suffix columns are wrapped in columns, so put the\n      // character counter before that.\n      else if (\n        this.$input.parent().is(\".columns\") &&\n        this.$input.parent().parent().is(\".row\")\n      ) {\n        this.$input.parent().parent().after(this.$target);\n      } else {\n        this.$input.after(this.$target);\n      }\n    }\n\n    if (this.$target.length > 0 && (this.maxCharacters > 0 || this.minCharacters > 0)) {\n      this.bindEvents();\n    }\n  }\n\n  bindEvents() {\n    // In WYSIWYG editors (Quill) we need to find the active editor from the\n    // DOM node. Quill has the experimental \"find\" method that should work\n    // fine in this case\n    if (Quill && this.$input.parent().is(\".editor\")) {\n      // Wait until the next javascript loop so Quill editors are created\n      setTimeout(() => {\n        const editor = Quill.find(this.$input.siblings(\".editor-container\")[0]);\n        editor.on(\"text-change\", () => {\n          this.updateStatus();\n        });\n      })\n    }\n    this.$input.on(\"keyup\", () => {\n      this.updateStatus();\n    });\n    if (this.$input.get(0) !== null) {\n      this.$input.get(0).addEventListener(\"emoji.added\", () => {\n        this.updateStatus();\n      });\n    }\n    this.updateStatus();\n  }\n\n  updateStatus() {\n    const numCharacters = this.$input.val().length;\n    const showMessages = [];\n\n    if (this.minCharacters > 0) {\n      let message = MESSAGES.charactersAtLeast.other;\n      if (this.minCharacters === 1) {\n        message = MESSAGES.charactersAtLeast.one;\n      }\n      showMessages.push(message.replace(COUNT_KEY, this.minCharacters));\n    }\n\n    if (this.maxCharacters > 0) {\n      const remaining = this.maxCharacters - numCharacters;\n      let message = MESSAGES.charactersLeft.other;\n      if (remaining === 1) {\n        message = MESSAGES.charactersLeft.one;\n      }\n      this.$input[0].dispatchEvent(\n        new CustomEvent(\"characterCounter\", {detail: {remaining: remaining}})\n      );\n      showMessages.push(message.replace(COUNT_KEY, remaining));\n    }\n\n    this.$target.text(showMessages.join(\", \"));\n  }\n}\n\nconst createCharacterCounter = ($input) => {\n  $input.data(\"remaining-characters-counter\", new InputCharacterCounter($input));\n}\n\n$(() => {\n  $(\"input[type='text'], textarea, .editor>input[type='hidden']\").each((_i, elem) => {\n    const $input = $(elem);\n\n    if (!$input.is(\"[minlength]\") && !$input.is(\"[maxlength]\")) {\n      return;\n    }\n\n    createCharacterCounter($input);\n  });\n});\n\nexport {InputCharacterCounter, createCharacterCounter};\n"]},"metadata":{},"sourceType":"module"}