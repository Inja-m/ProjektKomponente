{"ast":null,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\n\nimport ApiFetcher from \"src/decidim/decidim_awesome/awesome_map/api/api_fetcher\";\n\nvar Fetcher = /*#__PURE__*/function () {\n  function Fetcher(controller) {\n    _classCallCheck(this, Fetcher);\n\n    this.controller = controller;\n    this.config = {\n      length: controller.awesomeMap.config.length || 255\n    };\n\n    this.onFinished = function () {};\n\n    this.onNode = function () {};\n\n    this.onCollection = function () {};\n\n    this.hashtags = [];\n    this.collection = this.controller.component.type; // override in specific components:\n\n    this.query = \"query ($id: ID!, $after: String!) {\\n        component(id: $id) {\\n          id\\n          __typename\\n        }\\n      }\";\n  }\n\n  _createClass(Fetcher, [{\n    key: \"fetch\",\n    value: function fetch() {\n      var _this = this;\n\n      var after = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n      var variables = {\n        \"id\": this.controller.component.id,\n        \"after\": after\n      };\n      var api = new ApiFetcher(this.query, variables);\n      api.fetchAll(function (result) {\n        if (result) {\n          var collection = result.component[_this.collection]; // console.log(\"collection\",collection)\n\n          collection.edges.forEach(function (element) {\n            var node = element.node;\n\n            if (!node) {\n              return;\n            }\n\n            if (node.coordinates && node.coordinates.latitude && node.coordinates.longitude) {\n              _this.decorateNode(node);\n\n              _this.onNode(node);\n            }\n          });\n\n          _this.onCollection(collection);\n\n          if (collection.pageInfo.hasNextPage) {\n            _this.fetch(collection.pageInfo.endCursor);\n          } else {\n            _this.onFinished();\n          }\n        }\n      });\n    }\n  }, {\n    key: \"decorateNode\",\n    value: function decorateNode(node) {\n      var body = this.findTranslation(node.body.translations);\n      var title = this.findTranslation(node.title.translations);\n      node.hashtags = this.collectHashtags(title);\n      node.hashtags = node.hashtags.concat(this.collectHashtags(body)); // hashtags in the title look ugly, lets replace the gid:... structure with the tag #name\n\n      node.title.translation = this.replaceHashtags(title, node.hashtags);\n      node.body.translation = this.appendHtmlHashtags(this.truncate(this.removeHashtags(body)).replace(/\\n/g, \"<br>\"), node.hashtags);\n      node.link = \"\".concat(this.controller.component.url, \"/\").concat(this.collection, \"/\").concat(node.id);\n    }\n  }, {\n    key: \"findTranslation\",\n    value: function findTranslation(translations) {\n      var text,\n          lang = document.querySelector(\"html\").getAttribute(\"lang\");\n      translations.forEach(function (t) {\n        if (t.text) {\n          if (!text || t.locale == lang) {\n            text = t.text;\n          }\n        }\n      });\n      return text;\n    }\n  }, {\n    key: \"collectHashtags\",\n    value: function collectHashtags(text) {\n      var _this2 = this;\n\n      var tags = [];\n\n      if (text) {\n        var gids = text.match(/gid:\\/\\/[^\\s<&]+/g);\n\n        if (gids) {\n          tags = gids.filter(function (gid) {\n            return gid.indexOf(\"/Decidim::Hashtag/\") != -1;\n          }).map(function (gid) {\n            var parts = gid.split(\"/\");\n            var fromSelector = parts[5].charAt(0) == \"_\";\n            var tag = fromSelector ? parts[5].substr(1) : parts[5];\n            var name = \"#\".concat(tag);\n            var html = \"<a href=\\\"/search?term=\".concat(name, \"\\\">\").concat(name, \"</a>\");\n            var hashtag = {\n              color: getComputedStyle(document.documentElement).getPropertyValue(\"--secondary\"),\n              gid: gid,\n              id: parseInt(parts[4], 10),\n              fromSelector: fromSelector,\n              tag: tag,\n              name: name,\n              html: html\n            };\n\n            _this2.hashtags.push(hashtag);\n\n            return hashtag;\n          });\n        }\n      }\n\n      return tags;\n    }\n  }, {\n    key: \"replaceHashtags\",\n    value: function replaceHashtags(text, hashtags) {\n      hashtags.forEach(function (tag) {\n        text = text.replace(tag.gid, tag.name);\n      });\n      return text;\n    }\n  }, {\n    key: \"removeHashtags\",\n    value: function removeHashtags(text) {\n      return text.replace(/gid:\\/\\/[^\\s<&]+/g, \"\");\n    }\n  }, {\n    key: \"appendHtmlHashtags\",\n    value: function appendHtmlHashtags(text, tags) {\n      tags.forEach(function (tag) {\n        text += \" \".concat(tag.html);\n      });\n      return text;\n    }\n  }, {\n    key: \"truncate\",\n    value: function truncate(html) {\n      return $.truncate(html, this.config);\n    }\n  }]);\n\n  return Fetcher;\n}();\n\nexport { Fetcher as default };","map":{"version":3,"mappings":"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","names":["ApiFetcher","Fetcher","controller","_classCallCheck","config","length","awesomeMap","onFinished","onNode","onCollection","hashtags","collection","component","type","query","after","variables","id","api","fetchAll","result","_this","edges","forEach","element","node","coordinates","latitude","longitude","decorateNode","pageInfo","hasNextPage","fetch","endCursor","body","findTranslation","translations","title","collectHashtags","concat","translation","replaceHashtags","appendHtmlHashtags","truncate","removeHashtags","replace","link","url","text","lang","document","querySelector","getAttribute","t","locale","tags","gids","match","filter","gid","indexOf","map","parts","split","fromSelector","charAt","tag","substr","name","html","hashtag","color","getComputedStyle","documentElement","getPropertyValue","parseInt","_this2","push","$"],"sources":["/home/injam/.rbenv/versions/2.7.5/lib/ruby/gems/2.7.0/gems/decidim-decidim_awesome-0.8.3/app/packs/src/decidim/decidim_awesome/awesome_map/api/fetcher.js"],"sourcesContent":["import ApiFetcher from \"src/decidim/decidim_awesome/awesome_map/api/api_fetcher\";\n\nexport default class Fetcher {\n  constructor(controller) {\n    this.controller = controller;\n    this.config = {\n      length: controller.awesomeMap.config.length || 255\n    };\n    this.onFinished = () => {};\n    this.onNode = () => {};\n    this.onCollection = () => {};\n    this.hashtags = [];\n\n    this.collection = this.controller.component.type;\n    // override in specific components:\n    this.query = `query ($id: ID!, $after: String!) {\n        component(id: $id) {\n          id\n          __typename\n        }\n      }`;\n  }\n\n  fetch(after = \"\") {\n    const variables = {\n      \"id\": this.controller.component.id,\n      \"after\": after\n    };\n    const api = new ApiFetcher(this.query, variables);\n    api.fetchAll((result) => {\n      if (result) {\n        const collection = result.component[this.collection];\n        // console.log(\"collection\",collection)\n        \n        collection.edges.forEach((element) => {\n          let node = element.node;\n          if (!node) {\n            return;\n          }\n      \n          if (node.coordinates && node.coordinates.latitude && node.coordinates.longitude) {\n            this.decorateNode(node);\n            this.onNode(node)\n          }\n        });\n\n        this.onCollection(collection);\n\n        if (collection.pageInfo.hasNextPage) {\n          this.fetch(collection.pageInfo.endCursor);\n        } else {\n          this.onFinished();\n        }\n      }\n    });\n  }\n\n  decorateNode(node) {\n    const body = this.findTranslation(node.body.translations);\n    const title = this.findTranslation(node.title.translations);\n    node.hashtags = this.collectHashtags(title);\n    node.hashtags = node.hashtags.concat(this.collectHashtags(body));\n    // hashtags in the title look ugly, lets replace the gid:... structure with the tag #name\n    node.title.translation = this.replaceHashtags(title, node.hashtags);\n    node.body.translation = this.appendHtmlHashtags(this.truncate(this.removeHashtags(body)).replace(/\\n/g, \"<br>\"), node.hashtags);\n    node.link = `${this.controller.component.url}/${this.collection}/${node.id}`;\n  }\n\n  findTranslation(translations) {\n    let text, \n        lang = document.querySelector(\"html\").getAttribute(\"lang\");\n    \n    translations.forEach((t) => {\n      if (t.text) {\n        if (!text || t.locale == lang) {\n          text = t.text\n        }\n      }\n    });\n    return text;\n  }\n\n  collectHashtags(text) {\n    let tags = [];\n    if (text) {\n      const gids = text.match(/gid:\\/\\/[^\\s<&]+/g)\n      if (gids) {\n        tags = gids.filter((gid) => gid.indexOf(\"/Decidim::Hashtag/\") != -1).map((gid) => {\n          const parts = gid.split(\"/\");\n          const fromSelector = parts[5].charAt(0) == \"_\";\n          const tag = fromSelector\n            ? parts[5].substr(1)\n            : parts[5];\n          const name = `#${tag}`;\n          const html = `<a href=\"/search?term=${name}\">${name}</a>`;\n          const hashtag = {\n            color: getComputedStyle(document.documentElement).getPropertyValue(\"--secondary\"),\n            gid: gid,\n            id: parseInt(parts[4], 10),\n            fromSelector: fromSelector,\n            tag: tag,\n            name: name,\n            html: html\n          }\n          this.hashtags.push(hashtag)\n          return hashtag;\n        });\n      }\n    }\n    return tags;\n  }\n\n  replaceHashtags(text, hashtags) {\n    hashtags.forEach((tag) => {\n      text = text.replace(tag.gid, tag.name)\n    });\n    return text;\n  }\n\n  removeHashtags(text) {\n    return text.replace(/gid:\\/\\/[^\\s<&]+/g, \"\");\n  }\n\n  appendHtmlHashtags(text, tags) {\n    tags.forEach((tag) => {\n      text += ` ${tag.html}`;\n    });\n    return text;\n  }\n\n  truncate(html) {\n    return $.truncate(html, this.config);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}